using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Grinspector.Generator;

[Generator]
public class GrinspectorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Strategy: Find all [Grinspect(typeof(...))] attributes and generate for those types
        var targetTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is MethodDeclarationSyntax or ClassDeclarationSyntax,
                transform: static (ctx, _) => GetTargetTypesFromGrinspectAttribute(ctx))
            .Where(static types => types.Any())
            .SelectMany(static (types, _) => types)
            .Collect();

        context.RegisterSourceOutput(targetTypes, static (spc, types) => 
        {
            foreach (var targetType in types.Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default))
            {
                if (targetType != null)
                {
                    GenerateForClass(targetType, spc);
                }
            }
        });
    }
    
    private static IEnumerable<INamedTypeSymbol> GetTargetTypesFromGrinspectAttribute(GeneratorSyntaxContext context)
    {
        ISymbol? symbol = context.Node switch
        {
            MethodDeclarationSyntax method => context.SemanticModel.GetDeclaredSymbol(method),
            ClassDeclarationSyntax cls => context.SemanticModel.GetDeclaredSymbol(cls),
            _ => null
        };
        
        if (symbol == null)
            yield break;
            
        // Find all [InternalsAvailable(typeof(...))] attributes
        foreach (var attribute in symbol.GetAttributes())
        {
            if (attribute.AttributeClass?.Name != "InternalsAvailableAttribute" && 
                attribute.AttributeClass?.Name != "InternalsAvailable")
                continue;
                
            // Get the type from the first constructor argument
            if (attribute.ConstructorArguments.Length > 0)
            {
                var typeArg = attribute.ConstructorArguments[0];
                if (typeArg.Value is INamedTypeSymbol targetType)
                {
                    yield return targetType;
                }
            }
        }
    }
    
    private static void GenerateForClass(INamedTypeSymbol classSymbol, SourceProductionContext context)
    {
        // Skip the Grinspector class itself
        if (classSymbol.Name == "Grinspector" && classSymbol.ContainingNamespace?.ToDisplayString() == "Grinspector")
            return;

        // Get all private instance methods
        var privateMethods = classSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Private 
                     && !m.IsStatic 
                     && m.MethodKind == MethodKind.Ordinary)
            .ToList();

        // Get all private instance properties
        var privateProperties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Private && !p.IsStatic)
            .ToList();

        // Get all private instance fields
        var privateFields = classSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => f.DeclaredAccessibility == Accessibility.Private 
                     && !f.IsStatic
                     && !f.IsImplicitlyDeclared) // Skip compiler-generated backing fields
            .ToList();

        if (privateMethods.Count == 0 && privateProperties.Count == 0 && privateFields.Count == 0)
            return;

        var source = GenerateGrinspectorPartial(classSymbol, privateMethods, privateProperties, privateFields);
        var fileName = $"Internals_{classSymbol.Name}_{classSymbol.ContainingNamespace?.ToDisplayString().Replace(".", "_")}.g.cs";
        context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateGrinspectorPartial(INamedTypeSymbol targetType, List<IMethodSymbol> methods, 
        List<IPropertySymbol> properties, List<IFieldSymbol> fields)
    {
        var sb = new StringBuilder();
        var fullTypeName = targetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var simpleTypeName = targetType.Name;
        var targetNamespace = targetType.ContainingNamespace?.ToDisplayString() ?? "Global";
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace}");
        sb.AppendLine("{");
        
        // Generate a wrapper class for accessing private members
        sb.AppendLine($"    public class Internals_{simpleTypeName}");
        sb.AppendLine("    {");
        sb.AppendLine($"        private readonly {fullTypeName} _instance;");
        sb.AppendLine();
        sb.AppendLine($"        public Internals_{simpleTypeName}({fullTypeName} instance)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (instance == null)");
        sb.AppendLine("                throw new System.ArgumentNullException(nameof(instance));");
        sb.AppendLine("            _instance = instance;");
        sb.AppendLine("        }");
        sb.AppendLine();

        foreach (var method in methods)
        {
            GenerateMethodWrapper(sb, method);
        }

        foreach (var property in properties)
        {
            GeneratePropertyWrapper(sb, property);
        }

        foreach (var field in fields)
        {
            GenerateFieldWrapper(sb, field);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateMethodWrapper(StringBuilder sb, IMethodSymbol method)
    {
        var methodName = method.Name;
        var returnType = method.ReturnType.ToDisplayString();
        var parameters = string.Join(", ", method.Parameters.Select(p => 
            $"{p.Type.ToDisplayString()} {p.Name}"));
        var arguments = string.Join(", ", method.Parameters.Select(p => p.Name));

        sb.AppendLine($"        public {returnType} {methodName}({parameters})");
        sb.AppendLine("        {");
        
        // Use reflection to invoke the private method
        var typeFullName = method.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        sb.AppendLine($"            var methodInfo = typeof({typeFullName}).GetMethod(\"{methodName}\", ");
        sb.AppendLine($"                System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);");
        sb.AppendLine();
        sb.AppendLine("            if (methodInfo == null)");
        sb.AppendLine($"                throw new System.InvalidOperationException(\"Method '{methodName}' not found\");");
        sb.AppendLine();

        if (method.ReturnsVoid)
        {
            if (method.Parameters.Length == 0)
            {
                sb.AppendLine("            methodInfo.Invoke(_instance, null);");
            }
            else
            {
                sb.AppendLine($"            methodInfo.Invoke(_instance, new object?[] {{ {arguments} }});");
            }
        }
        else
        {
            if (method.Parameters.Length == 0)
            {
                sb.AppendLine($"            return ({returnType})methodInfo.Invoke(_instance, null)!;");
            }
            else
            {
                sb.AppendLine($"            return ({returnType})methodInfo.Invoke(_instance, new object?[] {{ {arguments} }})!;");
            }
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GeneratePropertyWrapper(StringBuilder sb, IPropertySymbol property)
    {
        var propertyName = property.Name;
        var propertyType = property.Type.ToDisplayString();
        var typeFullName = property.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        sb.AppendLine($"        public {propertyType} {propertyName}");
        sb.AppendLine("        {");

        // Generate getter if the property has one
        if (property.GetMethod != null)
        {
            sb.AppendLine("            get");
            sb.AppendLine("            {");
            sb.AppendLine($"                var propertyInfo = typeof({typeFullName}).GetProperty(\"{propertyName}\", ");
            sb.AppendLine($"                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);");
            sb.AppendLine();
            sb.AppendLine("                if (propertyInfo == null)");
            sb.AppendLine($"                    throw new System.InvalidOperationException(\"Property '{propertyName}' not found\");");
            sb.AppendLine();
            sb.AppendLine($"                return ({propertyType})propertyInfo.GetValue(_instance)!;");
            sb.AppendLine("            }");
        }

        // Generate setter if the property has one
        if (property.SetMethod != null)
        {
            sb.AppendLine("            set");
            sb.AppendLine("            {");
            sb.AppendLine($"                var propertyInfo = typeof({typeFullName}).GetProperty(\"{propertyName}\", ");
            sb.AppendLine($"                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);");
            sb.AppendLine();
            sb.AppendLine("                if (propertyInfo == null)");
            sb.AppendLine($"                    throw new System.InvalidOperationException(\"Property '{propertyName}' not found\");");
            sb.AppendLine();
            sb.AppendLine("                propertyInfo.SetValue(_instance, value);");
            sb.AppendLine("            }");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateFieldWrapper(StringBuilder sb, IFieldSymbol field)
    {
        var fieldName = field.Name;
        var fieldType = field.Type.ToDisplayString();
        var typeFullName = field.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        sb.AppendLine($"        public {fieldType} {fieldName}");
        sb.AppendLine("        {");
        sb.AppendLine("            get");
        sb.AppendLine("            {");
        sb.AppendLine($"                var fieldInfo = typeof({typeFullName}).GetField(\"{fieldName}\", ");
        sb.AppendLine($"                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);");
        sb.AppendLine();
        sb.AppendLine("                if (fieldInfo == null)");
        sb.AppendLine($"                    throw new System.InvalidOperationException(\"Field '{fieldName}' not found\");");
        sb.AppendLine();
        sb.AppendLine($"                return ({fieldType})fieldInfo.GetValue(_instance)!;");
        sb.AppendLine("            }");

        // Fields are always settable unless readonly
        if (!field.IsReadOnly)
        {
            sb.AppendLine("            set");
            sb.AppendLine("            {");
            sb.AppendLine($"                var fieldInfo = typeof({typeFullName}).GetField(\"{fieldName}\", ");
            sb.AppendLine($"                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);");
            sb.AppendLine();
            sb.AppendLine("                if (fieldInfo == null)");
            sb.AppendLine($"                    throw new System.InvalidOperationException(\"Field '{fieldName}' not found\");");
            sb.AppendLine();
            sb.AppendLine("                fieldInfo.SetValue(_instance, value);");
            sb.AppendLine("            }");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }
}
